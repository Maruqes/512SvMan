// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/marques/.gvm/pkgsets/go1.25.0/global/pkg/mod/libvirt.org/go/libvirt@v1.11006.0/lxc.go:1:1
//go:build !libvirt_without_lxc
// +build !libvirt_without_lxc

/*
 * This file is part of the libvirt-go-module project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Copyright (c) 2013 Alex Zorin
 * Copyright (C) 2016 Red Hat, Inc.
 *
 */

package libvirt; import _cgo_unsafe "unsafe"

/*
#cgo !libvirt_dlopen pkg-config: libvirt
// Can't rely on pkg-config for libvirt-lxc since it was not
// installed until 2.6.0 onwards
#cgo !libvirt_dlopen LDFLAGS: -lvirt-lxc
#cgo libvirt_dlopen LDFLAGS: -ldl
#cgo libvirt_dlopen CFLAGS: -DLIBVIRT_DLOPEN
#include <stdlib.h>
#include <string.h>
#include "libvirt_lxc_generated.h"
*/
import _ "unsafe"

import (
	"os"
	"unsafe"
)

func (d *Domain) LxcOpenNamespace(flags uint32) ([]os.File, error) {
	var cfdlist * /*line :51:15*/_Ctype_int /*line :51:20*/

	var err  /*line :53:10*/_Ctype_virError /*line :53:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :54:44*/d.ptr; _cgoBase1 := /*line :54:51*/&cfdlist; _cgo1 := _cgoBase1; var _cgo2 _Ctype_uint = _Ctype_uint /*line :54:67*/(flags); _cgoBase3 := /*line :54:76*/&err; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :54:81*/_Cfunc_virDomainLxcOpenNamespaceWrapper(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret == -1 {
		return []os.File{}, makeError(&err)
	}
	fdlist := make([]os.File, ret)
	for i := 0; i < int(ret); i++ {
		var cfd  /*line :60:11*/_Ctype_int /*line :60:16*/
		cfd = *(* /*line :61:12*/_Ctype_int /*line :61:17*/)(unsafe.Pointer(uintptr(unsafe.Pointer(cfdlist)) + (unsafe.Sizeof(cfd) * uintptr(i))))
		fdlist[i] = *os.NewFile(uintptr(cfd), "namespace")
	}
	defer func() func() { _cgo0 := /*line :64:15*/unsafe.Pointer(cfdlist); return func() { _cgoCheckPointer(_cgo0, nil); /*line :64:39*/_Cfunc_free(_cgo0); }}()()
	return fdlist, nil
}

func (d *Domain) LxcEnterNamespace(fdlist []os.File, flags uint32) ([]os.File, error) {
	var coldfdlist * /*line :69:18*/_Ctype_int /*line :69:23*/
	var ncoldfdlist  /*line :70:18*/_Ctype_uint /*line :70:24*/
	nfdlist := len(fdlist)
	cfdlist := make([] /*line :72:20*/_Ctype_int /*line :72:25*/, nfdlist)
	for i := 0; i < nfdlist; i++ {
		cfdlist[i] =  /*line :74:16*/_Ctype_int /*line :74:21*/(fdlist[i].Fd())
	}

	var err  /*line :77:10*/_Ctype_virError /*line :77:20*/
	var cfdlistPtr * /*line :78:18*/_Ctype_int /*line :78:23*/ = nil
	if nfdlist > 0 {
		cfdlistPtr = &cfdlist[0]
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :82:45*/d.ptr; var _cgo1 _Ctype_uint = _Ctype_uint /*line :82:58*/(nfdlist); var _cgo2 *_Ctype_int = /*line :82:69*/cfdlistPtr; var _cgo3 *_Ctype_uint = /*line :82:81*/&ncoldfdlist; _cgoBase4 := /*line :82:95*/&coldfdlist; _cgo4 := _cgoBase4; var _cgo5 _Ctype_uint = _Ctype_uint /*line :82:114*/(flags); _cgoBase6 := /*line :82:123*/&err; _cgo6 := _cgoBase6; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); _cgoCheckPointer(_cgoBase6, 0 == 0); return /*line :82:128*/_Cfunc_virDomainLxcEnterNamespaceWrapper(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	if ret == -1 {
		return []os.File{}, makeError(&err)
	}
	oldfdlist := make([]os.File, ncoldfdlist)
	for i := 0; i < int(ncoldfdlist); i++ {
		var cfd  /*line :88:11*/_Ctype_int /*line :88:16*/
		cfd = *(* /*line :89:12*/_Ctype_int /*line :89:17*/)(unsafe.Pointer(uintptr(unsafe.Pointer(coldfdlist)) + (unsafe.Sizeof(cfd) * uintptr(i))))
		oldfdlist[i] = *os.NewFile(uintptr(cfd), "namespace")
	}
	defer func() func() { _cgo0 := /*line :92:15*/unsafe.Pointer(coldfdlist); return func() { _cgoCheckPointer(_cgo0, nil); /*line :92:42*/_Cfunc_free(_cgo0); }}()()
	return oldfdlist, nil
}

func DomainLxcEnterSecurityLabel(model *NodeSecurityModel, label *SecurityLabel, flags uint32) (*SecurityLabel, error) {
	var cmodel  /*line :97:13*/_Ctype_virSecurityModel /*line :97:31*/
	var clabel  /*line :98:13*/_Ctype_virSecurityLabel /*line :98:31*/
	var coldlabel  /*line :99:16*/_Ctype_virSecurityLabel /*line :99:34*/

	cmodelstrlen := len(model.Model)
	if cmodelstrlen > (( /*line :102:21*/_Ciconst_VIR_SECURITY_MODEL_BUFLEN /*line :102:47*/) - 1) {
		cmodelstrlen = ( /*line :103:18*/_Ciconst_VIR_SECURITY_MODEL_BUFLEN /*line :103:44*/) - 1
	}
	cmodelstr := ( /*line :105:15*/_Cfunc_CString /*line :105:23*/)(model.Model)
	defer func() func() { _cgo0 := /*line :106:15*/unsafe.Pointer(cmodelstr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :106:41*/_Cfunc_free(_cgo0); }}()()

	cdoistrlen := len(model.Doi)
	if cdoistrlen >= (( /*line :109:20*/_Ciconst_VIR_SECURITY_DOI_BUFLEN /*line :109:44*/) - 1) {
		cdoistrlen = ( /*line :110:16*/_Ciconst_VIR_SECURITY_DOI_BUFLEN /*line :110:40*/) - 1
	}
	cdoistr := ( /*line :112:13*/_Cfunc_CString /*line :112:21*/)(model.Doi)
	defer func() func() { _cgo0 := /*line :113:15*/unsafe.Pointer(cdoistr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :113:39*/_Cfunc_free(_cgo0); }}()()

	func() _cgo_unsafe.Pointer{ _cgoBase0 := /*line :115:26*/&cmodel.model; _cgo0 := /*line :115:11*/unsafe.Pointer(_cgoBase0); _cgo1 := /*line :115:42*/unsafe.Pointer(cmodelstr); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :115:77*/(cmodelstrlen); _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgo1, nil); return /*line :115:92*/_Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
	func() _cgo_unsafe.Pointer{ _cgoBase0 := /*line :116:26*/&cmodel.doi; _cgo0 := /*line :116:11*/unsafe.Pointer(_cgoBase0); _cgo1 := /*line :116:40*/unsafe.Pointer(cdoistr); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :116:73*/(cdoistrlen); _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgo1, nil); return /*line :116:86*/_Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()

	clabelstrlen := len(label.Label)
	if clabelstrlen > (( /*line :119:21*/_Ciconst_VIR_SECURITY_LABEL_BUFLEN /*line :119:47*/) - 1) {
		clabelstrlen = ( /*line :120:18*/_Ciconst_VIR_SECURITY_LABEL_BUFLEN /*line :120:44*/) - 1
	}
	clabelstr := ( /*line :122:15*/_Cfunc_CString /*line :122:23*/)(label.Label)
	defer func() func() { _cgo0 := /*line :123:15*/unsafe.Pointer(clabelstr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :123:41*/_Cfunc_free(_cgo0); }}()()

	func() _cgo_unsafe.Pointer{ _cgoBase0 := /*line :125:26*/&clabel.label; _cgo0 := /*line :125:11*/unsafe.Pointer(_cgoBase0); _cgo1 := /*line :125:42*/unsafe.Pointer(clabelstr); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :125:77*/(clabelstrlen); _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgo1, nil); return /*line :125:92*/_Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
	if label.Enforcing {
		clabel.enforcing = 1
	} else {
		clabel.enforcing = 0
	}

	var err  /*line :132:10*/_Ctype_virError /*line :132:20*/
	ret := func() _Ctype_int{ var _cgo0 *_Ctype_struct__virSecurityModel = /*line :133:49*/&cmodel; var _cgo1 *_Ctype_struct__virSecurityLabel = /*line :133:58*/&clabel; var _cgo2 *_Ctype_struct__virSecurityLabel = /*line :133:67*/&coldlabel; var _cgo3 _Ctype_uint = _Ctype_uint /*line :133:85*/(flags); _cgoBase4 := /*line :133:94*/&err; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :133:99*/_Cfunc_virDomainLxcEnterSecurityLabelWrapper(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if ret == -1 {
		return nil, makeError(&err)
	}

	var oldlabel SecurityLabel

	oldlabel.Label = ( /*line :140:19*/_Cfunc_GoString /*line :140:28*/)((* /*line :140:32*/_Ctype_char /*line :140:38*/)(unsafe.Pointer(&coldlabel.label)))
	if coldlabel.enforcing != 0 {
		oldlabel.Enforcing = true
	} else {
		oldlabel.Enforcing = false
	}

	return &oldlabel, nil
}

func (d *Domain) DomainLxcEnterCGroup(flags uint32) error {
	var err  /*line :151:10*/_Ctype_virError /*line :151:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :152:42*/d.ptr; var _cgo1 _Ctype_uint = _Ctype_uint /*line :152:55*/(flags); _cgoBase2 := /*line :152:64*/&err; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :152:69*/_Cfunc_virDomainLxcEnterCGroupWrapper(_cgo0, _cgo1, _cgo2); }()

	if ret == -1 {
		return makeError(&err)
	}

	return nil
}
