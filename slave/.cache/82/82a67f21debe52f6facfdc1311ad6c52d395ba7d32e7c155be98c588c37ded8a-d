// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/marques/.gvm/pkgsets/go1.25.0/global/pkg/mod/github.com/coreos/go-systemd/v22@v22.6.0/internal/dlopen/dlopen.go:1:1
// Copyright 2016 CoreOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package dlopen provides some convenience functions to dlopen a library and
// get its symbols.
package dlopen; import _cgo_unsafe "unsafe"

// #cgo LDFLAGS: -ldl
// #include <stdlib.h>
// #include <dlfcn.h>
import _ "unsafe"

import (
	"errors"
	"fmt"
	"runtime"
	"unsafe"
)

var ErrSoNotFound = errors.New("unable to open a handle to the library")

// LibHandle represents an open handle to a library (.so)
type LibHandle struct {
	Handle  unsafe.Pointer
	Libname string
}

// GetHandle tries to get a handle to a library (.so), attempting to access it
// by the names specified in libs and returning the first that is successfully
// opened. Callers are responsible for closing the handler. If no library can
// be successfully opened, an error is returned.
func GetHandle(libs []string) (*LibHandle, error) {
	for _, name := range libs {
		libname := ( /*line :45:14*/_Cfunc_CString /*line :45:22*/)(name)
		defer func() func() { _cgo0 := /*line :46:16*/unsafe.Pointer(libname); return func() { _cgoCheckPointer(_cgo0, nil); /*line :46:40*/_Cfunc_free(_cgo0); }}()()
		handle := ( /*line :47:13*/_Cfunc_dlopen /*line :47:20*/)(libname, ( /*line :47:31*/_Ciconst_RTLD_LAZY /*line :47:41*/))
		if handle != nil {
			h := &LibHandle{
				Handle:  handle,
				Libname: name,
			}
			return h, nil
		}
	}
	return nil, ErrSoNotFound
}

// GetSymbolPointer takes a symbol name and returns a pointer to the symbol.
func (l *LibHandle) GetSymbolPointer(symbol string) (unsafe.Pointer, error) {
	// Locking the thread is critical here as the dlerror() is thread local so
	// go should not reschedule this onto another thread.
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	sym := ( /*line :65:9*/_Cfunc_CString /*line :65:17*/)(symbol)
	defer func() func() { _cgo0 := /*line :66:15*/unsafe.Pointer(sym); return func() { _cgoCheckPointer(_cgo0, nil); /*line :66:35*/_Cfunc_free(_cgo0); }}()()

	( /*line :68:2*/_Cfunc_dlerror /*line :68:10*/)()
	p := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :69:15*/l.Handle; var _cgo1 *_Ctype_char = /*line :69:25*/sym; _cgoCheckPointer(_cgo0, nil); return /*line :69:29*/_Cfunc_dlsym(_cgo0, _cgo1); }()
	e := ( /*line :70:7*/_Cfunc_dlerror /*line :70:15*/)()
	if e != nil {
		return nil, fmt.Errorf("error resolving symbol %q: %v", symbol, errors.New(( /*line :72:78*/_Cfunc_GoString /*line :72:87*/)(e)))
	}

	return p, nil
}

// Close closes a LibHandle.
func (l *LibHandle) Close() error {
	// Locking the thread is critical here as the dlerror() is thread local so
	// go should not reschedule this onto another thread.
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	( /*line :84:2*/_Cfunc_dlerror /*line :84:10*/)()
	func() _Ctype_int{ _cgo0 := /*line :85:12*/l.Handle; _cgoCheckPointer(_cgo0, nil); return /*line :85:21*/_Cfunc_dlclose(_cgo0); }()
	e := ( /*line :86:7*/_Cfunc_dlerror /*line :86:15*/)()
	if e != nil {
		return fmt.Errorf("error closing %v: %v", l.Libname, errors.New(( /*line :88:67*/_Cfunc_GoString /*line :88:76*/)(e)))
	}

	return nil
}
