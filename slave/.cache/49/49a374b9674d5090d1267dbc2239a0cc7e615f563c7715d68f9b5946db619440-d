// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/marques/.gvm/pkgsets/go1.25.0/global/pkg/mod/github.com/coreos/go-systemd/v22@v22.6.0/sdjournal/journal.go:1:1
// Copyright 2015 RedHat, Inc.
// Copyright 2015 CoreOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package sdjournal provides a low-level Go interface to the
// systemd journal wrapped around the sd-journal C API.
//
// All public read methods map closely to the sd-journal API functions. See the
// sd-journal.h documentation[1] for information about each function.
//
// To write to the journal, see the pure-Go "journal" package
//
// [1] http://www.freedesktop.org/software/systemd/man/sd-journal.html
package sdjournal

// #include <systemd/sd-journal.h>
// #include <systemd/sd-id128.h>
// #include <stdlib.h>
// #include <syslog.h>
//
// int
// my_sd_journal_open(void *f, sd_journal **ret, int flags)
// {
//   int (*sd_journal_open)(sd_journal **, int);
//
//   sd_journal_open = f;
//   return sd_journal_open(ret, flags);
// }
//
// int
// my_sd_journal_open_directory(void *f, sd_journal **ret, const char *path, int flags)
// {
//   int (*sd_journal_open_directory)(sd_journal **, const char *, int);
//
//   sd_journal_open_directory = f;
//   return sd_journal_open_directory(ret, path, flags);
// }
//
// int
// my_sd_journal_open_files(void *f, sd_journal **ret, const char **paths, int flags)
// {
//   int (*sd_journal_open_files)(sd_journal **, const char **, int);
//
//   sd_journal_open_files = f;
//   return sd_journal_open_files(ret, paths, flags);
// }
//
// void
// my_sd_journal_close(void *f, sd_journal *j)
// {
//   void (*sd_journal_close)(sd_journal *);
//
//   sd_journal_close = f;
//   sd_journal_close(j);
// }
//
// int
// my_sd_journal_get_usage(void *f, sd_journal *j, uint64_t *bytes)
// {
//   int (*sd_journal_get_usage)(sd_journal *, uint64_t *);
//
//   sd_journal_get_usage = f;
//   return sd_journal_get_usage(j, bytes);
// }
//
// int
// my_sd_journal_add_match(void *f, sd_journal *j, const void *data, size_t size)
// {
//   int (*sd_journal_add_match)(sd_journal *, const void *, size_t);
//
//   sd_journal_add_match = f;
//   return sd_journal_add_match(j, data, size);
// }
//
// int
// my_sd_journal_add_disjunction(void *f, sd_journal *j)
// {
//   int (*sd_journal_add_disjunction)(sd_journal *);
//
//   sd_journal_add_disjunction = f;
//   return sd_journal_add_disjunction(j);
// }
//
// int
// my_sd_journal_add_conjunction(void *f, sd_journal *j)
// {
//   int (*sd_journal_add_conjunction)(sd_journal *);
//
//   sd_journal_add_conjunction = f;
//   return sd_journal_add_conjunction(j);
// }
//
// void
// my_sd_journal_flush_matches(void *f, sd_journal *j)
// {
//   void (*sd_journal_flush_matches)(sd_journal *);
//
//   sd_journal_flush_matches = f;
//   sd_journal_flush_matches(j);
// }
//
// int
// my_sd_journal_next(void *f, sd_journal *j)
// {
//   int (*sd_journal_next)(sd_journal *);
//
//   sd_journal_next = f;
//   return sd_journal_next(j);
// }
//
// int
// my_sd_journal_next_skip(void *f, sd_journal *j, uint64_t skip)
// {
//   int (*sd_journal_next_skip)(sd_journal *, uint64_t);
//
//   sd_journal_next_skip = f;
//   return sd_journal_next_skip(j, skip);
// }
//
// int
// my_sd_journal_previous(void *f, sd_journal *j)
// {
//   int (*sd_journal_previous)(sd_journal *);
//
//   sd_journal_previous = f;
//   return sd_journal_previous(j);
// }
//
// int
// my_sd_journal_previous_skip(void *f, sd_journal *j, uint64_t skip)
// {
//   int (*sd_journal_previous_skip)(sd_journal *, uint64_t);
//
//   sd_journal_previous_skip = f;
//   return sd_journal_previous_skip(j, skip);
// }
//
// int
// my_sd_journal_get_data(void *f, sd_journal *j, const char *field, const void **data, size_t *length)
// {
//   int (*sd_journal_get_data)(sd_journal *, const char *, const void **, size_t *);
//
//   sd_journal_get_data = f;
//   return sd_journal_get_data(j, field, data, length);
// }
//
// int
// my_sd_journal_set_data_threshold(void *f, sd_journal *j, size_t sz)
// {
//   int (*sd_journal_set_data_threshold)(sd_journal *, size_t);
//
//   sd_journal_set_data_threshold = f;
//   return sd_journal_set_data_threshold(j, sz);
// }
//
// int
// my_sd_journal_get_cursor(void *f, sd_journal *j, char **cursor)
// {
//   int (*sd_journal_get_cursor)(sd_journal *, char **);
//
//   sd_journal_get_cursor = f;
//   return sd_journal_get_cursor(j, cursor);
// }
//
// int
// my_sd_journal_test_cursor(void *f, sd_journal *j, const char *cursor)
// {
//   int (*sd_journal_test_cursor)(sd_journal *, const char *);
//
//   sd_journal_test_cursor = f;
//   return sd_journal_test_cursor(j, cursor);
// }
//
// int
// my_sd_journal_get_realtime_usec(void *f, sd_journal *j, uint64_t *usec)
// {
//   int (*sd_journal_get_realtime_usec)(sd_journal *, uint64_t *);
//
//   sd_journal_get_realtime_usec = f;
//   return sd_journal_get_realtime_usec(j, usec);
// }
//
// int
// my_sd_journal_get_monotonic_usec(void *f, sd_journal *j, uint64_t *usec, sd_id128_t *boot_id)
// {
//   int (*sd_journal_get_monotonic_usec)(sd_journal *, uint64_t *, sd_id128_t *);
//
//   sd_journal_get_monotonic_usec = f;
//   return sd_journal_get_monotonic_usec(j, usec, boot_id);
// }
//
// int
// my_sd_journal_seek_head(void *f, sd_journal *j)
// {
//   int (*sd_journal_seek_head)(sd_journal *);
//
//   sd_journal_seek_head = f;
//   return sd_journal_seek_head(j);
// }
//
// int
// my_sd_journal_seek_tail(void *f, sd_journal *j)
// {
//   int (*sd_journal_seek_tail)(sd_journal *);
//
//   sd_journal_seek_tail = f;
//   return sd_journal_seek_tail(j);
// }
//
//
// int
// my_sd_journal_seek_cursor(void *f, sd_journal *j, const char *cursor)
// {
//   int (*sd_journal_seek_cursor)(sd_journal *, const char *);
//
//   sd_journal_seek_cursor = f;
//   return sd_journal_seek_cursor(j, cursor);
// }
//
// int
// my_sd_journal_seek_realtime_usec(void *f, sd_journal *j, uint64_t usec)
// {
//   int (*sd_journal_seek_realtime_usec)(sd_journal *, uint64_t);
//
//   sd_journal_seek_realtime_usec = f;
//   return sd_journal_seek_realtime_usec(j, usec);
// }
//
// int
// my_sd_journal_wait(void *f, sd_journal *j, uint64_t timeout_usec)
// {
//   int (*sd_journal_wait)(sd_journal *, uint64_t);
//
//   sd_journal_wait = f;
//   return sd_journal_wait(j, timeout_usec);
// }
//
// void
// my_sd_journal_restart_data(void *f, sd_journal *j)
// {
//   void (*sd_journal_restart_data)(sd_journal *);
//
//   sd_journal_restart_data = f;
//   sd_journal_restart_data(j);
// }
//
// int
// my_sd_journal_enumerate_data(void *f, sd_journal *j, const void **data, size_t *length)
// {
//   int (*sd_journal_enumerate_data)(sd_journal *, const void **, size_t *);
//
//   sd_journal_enumerate_data = f;
//   return sd_journal_enumerate_data(j, data, length);
// }
//
// int
// my_sd_journal_query_unique(void *f, sd_journal *j, const char *field)
// {
//   int(*sd_journal_query_unique)(sd_journal *, const char *);
//
//   sd_journal_query_unique = f;
//   return sd_journal_query_unique(j, field);
// }
//
// int
// my_sd_journal_enumerate_unique(void *f, sd_journal *j, const void **data, size_t *length)
// {
//   int(*sd_journal_enumerate_unique)(sd_journal *, const void **, size_t *);
//
//   sd_journal_enumerate_unique = f;
//   return sd_journal_enumerate_unique(j, data, length);
// }
//
// void
// my_sd_journal_restart_unique(void *f, sd_journal *j)
// {
//   void(*sd_journal_restart_unique)(sd_journal *);
//
//   sd_journal_restart_unique = f;
//   sd_journal_restart_unique(j);
// }
//
// int
// my_sd_journal_get_catalog(void *f, sd_journal *j, char **ret)
// {
//   int(*sd_journal_get_catalog)(sd_journal *, char **);
//
//   sd_journal_get_catalog = f;
//   return sd_journal_get_catalog(j, ret);
// }
//
// int
// my_sd_id128_get_boot(void *f, sd_id128_t *boot_id)
// {
//   int(*sd_id128_get_boot)(sd_id128_t *);
//
//   sd_id128_get_boot = f;
//   return sd_id128_get_boot(boot_id);
// }
//
// char *
// my_sd_id128_to_string(void *f, sd_id128_t boot_id, char s[SD_ID128_STRING_MAX])
// {
//   char *(*sd_id128_to_string)(sd_id128_t, char *);
//
//   sd_id128_to_string = f;
//   return sd_id128_to_string(boot_id, s);
// }
//
import _ "unsafe"

import (
	"bytes"
	"errors"
	"fmt"
	"strings"
	"sync"
	"syscall"
	"time"
	"unsafe"
)

// Journal entry field strings which correspond to:
// http://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html
const (
	// User Journal Fields
	SD_JOURNAL_FIELD_MESSAGE           = "MESSAGE"
	SD_JOURNAL_FIELD_MESSAGE_ID        = "MESSAGE_ID"
	SD_JOURNAL_FIELD_PRIORITY          = "PRIORITY"
	SD_JOURNAL_FIELD_CODE_FILE         = "CODE_FILE"
	SD_JOURNAL_FIELD_CODE_LINE         = "CODE_LINE"
	SD_JOURNAL_FIELD_CODE_FUNC         = "CODE_FUNC"
	SD_JOURNAL_FIELD_ERRNO             = "ERRNO"
	SD_JOURNAL_FIELD_SYSLOG_FACILITY   = "SYSLOG_FACILITY"
	SD_JOURNAL_FIELD_SYSLOG_IDENTIFIER = "SYSLOG_IDENTIFIER"
	SD_JOURNAL_FIELD_SYSLOG_PID        = "SYSLOG_PID"

	// Trusted Journal Fields
	SD_JOURNAL_FIELD_PID                       = "_PID"
	SD_JOURNAL_FIELD_UID                       = "_UID"
	SD_JOURNAL_FIELD_GID                       = "_GID"
	SD_JOURNAL_FIELD_COMM                      = "_COMM"
	SD_JOURNAL_FIELD_EXE                       = "_EXE"
	SD_JOURNAL_FIELD_CMDLINE                   = "_CMDLINE"
	SD_JOURNAL_FIELD_CAP_EFFECTIVE             = "_CAP_EFFECTIVE"
	SD_JOURNAL_FIELD_AUDIT_SESSION             = "_AUDIT_SESSION"
	SD_JOURNAL_FIELD_AUDIT_LOGINUID            = "_AUDIT_LOGINUID"
	SD_JOURNAL_FIELD_SYSTEMD_CGROUP            = "_SYSTEMD_CGROUP"
	SD_JOURNAL_FIELD_SYSTEMD_SESSION           = "_SYSTEMD_SESSION"
	SD_JOURNAL_FIELD_SYSTEMD_UNIT              = "_SYSTEMD_UNIT"
	SD_JOURNAL_FIELD_SYSTEMD_USER_UNIT         = "_SYSTEMD_USER_UNIT"
	SD_JOURNAL_FIELD_SYSTEMD_OWNER_UID         = "_SYSTEMD_OWNER_UID"
	SD_JOURNAL_FIELD_SYSTEMD_SLICE             = "_SYSTEMD_SLICE"
	SD_JOURNAL_FIELD_SELINUX_CONTEXT           = "_SELINUX_CONTEXT"
	SD_JOURNAL_FIELD_SOURCE_REALTIME_TIMESTAMP = "_SOURCE_REALTIME_TIMESTAMP"
	SD_JOURNAL_FIELD_BOOT_ID                   = "_BOOT_ID"
	SD_JOURNAL_FIELD_MACHINE_ID                = "_MACHINE_ID"
	SD_JOURNAL_FIELD_HOSTNAME                  = "_HOSTNAME"
	SD_JOURNAL_FIELD_TRANSPORT                 = "_TRANSPORT"

	// Address Fields
	SD_JOURNAL_FIELD_CURSOR              = "__CURSOR"
	SD_JOURNAL_FIELD_REALTIME_TIMESTAMP  = "__REALTIME_TIMESTAMP"
	SD_JOURNAL_FIELD_MONOTONIC_TIMESTAMP = "__MONOTONIC_TIMESTAMP"
)

// Journal event constants
const (
	SD_JOURNAL_NOP        = int(( /*line :380:30*/_Ciconst_SD_JOURNAL_NOP /*line :380:45*/))
	SD_JOURNAL_APPEND     = int(( /*line :381:30*/_Ciconst_SD_JOURNAL_APPEND /*line :381:48*/))
	SD_JOURNAL_INVALIDATE = int(( /*line :382:30*/_Ciconst_SD_JOURNAL_INVALIDATE /*line :382:52*/))
)

const (
	// IndefiniteWait is a sentinel value that can be passed to
	// sdjournal.Wait() to signal an indefinite wait for new journal
	// events. It is implemented as the maximum value for a time.Duration:
	// https://github.com/golang/go/blob/e4dcf5c8c22d98ac9eac7b9b226596229624cb1d/src/time/time.go#L434
	IndefiniteWait time.Duration = 1<<63 - 1
)

// ErrNoTestCursor gets returned when using TestCursor function and cursor
// parameter is not the same as the current cursor position.
var ErrNoTestCursor = errors.New("Cursor parameter is not the same as current position")

// Journal is a Go wrapper of an sd_journal structure.
type Journal struct {
	cjournal * /*line :399:12*/_Ctype_sd_journal /*line :399:24*/
	mu       sync.Mutex
}

// JournalEntry represents all fields of a journal entry plus address fields.
type JournalEntry struct {
	Fields             map[string]string
	Cursor             string
	RealtimeTimestamp  uint64
	MonotonicTimestamp uint64
}

// Match is a convenience wrapper to describe filters supplied to AddMatch.
type Match struct {
	Field string
	Value string
}

// String returns a string representation of a Match suitable for use with AddMatch.
func (m *Match) String() string {
	return m.Field + "=" + m.Value
}

// NewJournal returns a new Journal instance pointing to the local journal
func NewJournal() (j *Journal, err error) {
	j = &Journal{}

	sd_journal_open, err := getFunction("sd_journal_open")
	if err != nil {
		return nil, err
	}

	r := func() _Ctype_int{ _cgo0 := /*line :431:28*/sd_journal_open; _cgoBase1 := /*line :431:45*/&j.cjournal; _cgo1 := _cgoBase1; var _cgo2 _Ctype_int = /*line :431:58*/_Ciconst_SD_JOURNAL_LOCAL_ONLY /*line :431:81*/; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :431:82*/_Cfunc_my_sd_journal_open(_cgo0, _cgo1, _cgo2); }()

	if r < 0 {
		return nil, fmt.Errorf("failed to open journal: %s", syscall.Errno(-r).Error())
	}

	return j, nil
}

// NewJournalFromDir returns a new Journal instance pointing to a journal residing
// in a given directory.
func NewJournalFromDir(path string) (j *Journal, err error) {
	j = &Journal{}

	sd_journal_open_directory, err := getFunction("sd_journal_open_directory")
	if err != nil {
		return nil, err
	}

	p := ( /*line :450:7*/_Cfunc_CString /*line :450:15*/)(path)
	defer func() func() { _cgo0 := /*line :451:15*/unsafe.Pointer(p); return func() { _cgoCheckPointer(_cgo0, nil); /*line :451:33*/_Cfunc_free(_cgo0); }}()()

	r := func() _Ctype_int{ _cgo0 := /*line :453:38*/sd_journal_open_directory; _cgoBase1 := /*line :453:65*/&j.cjournal; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_char = /*line :453:78*/p; var _cgo3 _Ctype_int = /*line :453:81*/0; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :453:83*/_Cfunc_my_sd_journal_open_directory(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if r < 0 {
		return nil, fmt.Errorf("failed to open journal in directory %q: %s", path, syscall.Errno(-r).Error())
	}

	return j, nil
}

// NewJournalFromFiles returns a new Journal instance pointing to a journals residing
// in a given files.
func NewJournalFromFiles(paths ...string) (j *Journal, err error) {
	j = &Journal{}

	sd_journal_open_files, err := getFunction("sd_journal_open_files")
	if err != nil {
		return nil, err
	}

	// by making the slice 1 elem too long, we guarantee it'll be null-terminated
	cPaths := make([]* /*line :472:20*/_Ctype_char /*line :472:26*/, len(paths)+1)
	for idx, path := range paths {
		p := ( /*line :474:8*/_Cfunc_CString /*line :474:16*/)(path)
		cPaths[idx] = p
		defer func() func() { _cgo0 := /*line :476:16*/unsafe.Pointer(p); return func() { _cgoCheckPointer(_cgo0, nil); /*line :476:34*/_Cfunc_free(_cgo0); }}()()
	}

	r := func() _Ctype_int{ _cgo0 := /*line :479:34*/sd_journal_open_files; _cgoBase1 := /*line :479:57*/&j.cjournal; _cgo1 := _cgoBase1; _cgoIndex2 := &/*line :479:71*/cPaths; _cgo2 := /*line :479:70*/&(*_cgoIndex2)[0]; var _cgo3 _Ctype_int = /*line :479:82*/0; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :479:84*/_Cfunc_my_sd_journal_open_files(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if r < 0 {
		return nil, fmt.Errorf("failed to open journals in paths %q: %s", paths, syscall.Errno(-r).Error())
	}

	return j, nil
}

// Close closes a journal opened with NewJournal.
func (j *Journal) Close() error {
	sd_journal_close, err := getFunction("sd_journal_close")
	if err != nil {
		return err
	}

	j.mu.Lock()
	func() { _cgo0 := /*line :495:24*/sd_journal_close; _cgo1 := /*line :495:42*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :495:53*/_Cfunc_my_sd_journal_close(_cgo0, _cgo1); }()
	j.mu.Unlock()

	return nil
}

// AddMatch adds a match by which to filter the entries of the journal.
func (j *Journal) AddMatch(match string) error {
	sd_journal_add_match, err := getFunction("sd_journal_add_match")
	if err != nil {
		return err
	}

	m := ( /*line :508:7*/_Cfunc_CString /*line :508:15*/)(match)
	defer func() func() { _cgo0 := /*line :509:15*/unsafe.Pointer(m); return func() { _cgoCheckPointer(_cgo0, nil); /*line :509:33*/_Cfunc_free(_cgo0); }}()()

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :512:33*/sd_journal_add_match; _cgo1 := /*line :512:55*/j.cjournal; _cgo2 := /*line :512:67*/unsafe.Pointer(m); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :512:94*/(len(match)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return /*line :512:107*/_Cfunc_my_sd_journal_add_match(_cgo0, _cgo1, _cgo2, _cgo3); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to add match: %s", syscall.Errno(-r).Error())
	}

	return nil
}

// AddDisjunction inserts a logical OR in the match list.
func (j *Journal) AddDisjunction() error {
	sd_journal_add_disjunction, err := getFunction("sd_journal_add_disjunction")
	if err != nil {
		return err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :530:39*/sd_journal_add_disjunction; _cgo1 := /*line :530:67*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :530:78*/_Cfunc_my_sd_journal_add_disjunction(_cgo0, _cgo1); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to add a disjunction in the match list: %s", syscall.Errno(-r).Error())
	}

	return nil
}

// AddConjunction inserts a logical AND in the match list.
func (j *Journal) AddConjunction() error {
	sd_journal_add_conjunction, err := getFunction("sd_journal_add_conjunction")
	if err != nil {
		return err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :548:39*/sd_journal_add_conjunction; _cgo1 := /*line :548:67*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :548:78*/_Cfunc_my_sd_journal_add_conjunction(_cgo0, _cgo1); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to add a conjunction in the match list: %s", syscall.Errno(-r).Error())
	}

	return nil
}

// FlushMatches flushes all matches, disjunctions and conjunctions.
func (j *Journal) FlushMatches() {
	sd_journal_flush_matches, err := getFunction("sd_journal_flush_matches")
	if err != nil {
		return
	}

	j.mu.Lock()
	func() { _cgo0 := /*line :566:32*/sd_journal_flush_matches; _cgo1 := /*line :566:58*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :566:69*/_Cfunc_my_sd_journal_flush_matches(_cgo0, _cgo1); }()
	j.mu.Unlock()
}

// Next advances the read pointer into the journal by one entry.
func (j *Journal) Next() (uint64, error) {
	sd_journal_next, err := getFunction("sd_journal_next")
	if err != nil {
		return 0, err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :578:28*/sd_journal_next; _cgo1 := /*line :578:45*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :578:56*/_Cfunc_my_sd_journal_next(_cgo0, _cgo1); }()
	j.mu.Unlock()

	if r < 0 {
		return 0, fmt.Errorf("failed to iterate journal: %s", syscall.Errno(-r).Error())
	}

	return uint64(r), nil
}

// NextSkip advances the read pointer by multiple entries at once,
// as specified by the skip parameter.
func (j *Journal) NextSkip(skip uint64) (uint64, error) {
	sd_journal_next_skip, err := getFunction("sd_journal_next_skip")
	if err != nil {
		return 0, err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :597:33*/sd_journal_next_skip; _cgo1 := /*line :597:55*/j.cjournal; var _cgo2 _Ctype_uint64_t = _Ctype_uint64_t /*line :597:77*/(skip); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :597:84*/_Cfunc_my_sd_journal_next_skip(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	if r < 0 {
		return 0, fmt.Errorf("failed to iterate journal: %s", syscall.Errno(-r).Error())
	}

	return uint64(r), nil
}

// Previous sets the read pointer into the journal back by one entry.
func (j *Journal) Previous() (uint64, error) {
	sd_journal_previous, err := getFunction("sd_journal_previous")
	if err != nil {
		return 0, err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :615:32*/sd_journal_previous; _cgo1 := /*line :615:53*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :615:64*/_Cfunc_my_sd_journal_previous(_cgo0, _cgo1); }()
	j.mu.Unlock()

	if r < 0 {
		return 0, fmt.Errorf("failed to iterate journal: %s", syscall.Errno(-r).Error())
	}

	return uint64(r), nil
}

// PreviousSkip sets back the read pointer by multiple entries at once,
// as specified by the skip parameter.
func (j *Journal) PreviousSkip(skip uint64) (uint64, error) {
	sd_journal_previous_skip, err := getFunction("sd_journal_previous_skip")
	if err != nil {
		return 0, err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :634:37*/sd_journal_previous_skip; _cgo1 := /*line :634:63*/j.cjournal; var _cgo2 _Ctype_uint64_t = _Ctype_uint64_t /*line :634:85*/(skip); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :634:92*/_Cfunc_my_sd_journal_previous_skip(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	if r < 0 {
		return 0, fmt.Errorf("failed to iterate journal: %s", syscall.Errno(-r).Error())
	}

	return uint64(r), nil
}

func (j *Journal) getData(field string) (unsafe.Pointer,  /*line :644:58*/_Ctype_int /*line :644:63*/, error) {
	sd_journal_get_data, err := getFunction("sd_journal_get_data")
	if err != nil {
		return nil, 0, err
	}

	f := ( /*line :650:7*/_Cfunc_CString /*line :650:15*/)(field)
	defer func() func() { _cgo0 := /*line :651:15*/unsafe.Pointer(f); return func() { _cgoCheckPointer(_cgo0, nil); /*line :651:33*/_Cfunc_free(_cgo0); }}()()

	var d unsafe.Pointer
	var l  /*line :654:8*/_Ctype_size_t /*line :654:16*/

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :657:32*/sd_journal_get_data; _cgo1 := /*line :657:53*/j.cjournal; var _cgo2 *_Ctype_char = /*line :657:65*/f; _cgoBase3 := /*line :657:68*/&d; _cgo3 := _cgoBase3; var _cgo4 *_Ctype_size_t = /*line :657:72*/&l; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :657:75*/_Cfunc_my_sd_journal_get_data(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	j.mu.Unlock()

	if r < 0 {
		return nil, 0, fmt.Errorf("failed to read message: %s", syscall.Errno(-r).Error())
	}

	return d,  /*line :664:12*/_Ctype_int /*line :664:17*/(l), nil
}

// GetData gets the data object associated with a specific field from the
// the journal entry referenced by the last completed Next/Previous function
// call. To call GetData, you must have first called one of these functions.
func (j *Journal) GetData(field string) (string, error) {
	d, l, err := j.getData(field)
	if err != nil {
		return "", err
	}

	return ( /*line :676:9*/_Cfunc_GoStringN /*line :676:19*/)((* /*line :676:23*/_Ctype_char /*line :676:29*/)(d), l), nil
}

// GetDataValue gets the data object associated with a specific field from the
// journal entry referenced by the last completed Next/Previous function call,
// returning only the value of the object. To call GetDataValue, you must first
// have called one of the Next/Previous functions.
func (j *Journal) GetDataValue(field string) (string, error) {
	val, err := j.GetData(field)
	if err != nil {
		return "", err
	}

	return strings.SplitN(val, "=", 2)[1], nil
}

// GetDataBytes gets the data object associated with a specific field from the
// journal entry referenced by the last completed Next/Previous function call.
// To call GetDataBytes, you must first have called one of these functions.
func (j *Journal) GetDataBytes(field string) ([]byte, error) {
	d, l, err := j.getData(field)
	if err != nil {
		return nil, err
	}

	return func() []byte{ _cgo0 := /*line :701:19*/d; var _cgo1 _Ctype_int = /*line :701:22*/l; _cgoCheckPointer(_cgo0, nil); return /*line :701:24*/_Cfunc_GoBytes(_cgo0, _cgo1); }(), nil
}

// GetDataValueBytes gets the data object associated with a specific field from the
// journal entry referenced by the last completed Next/Previous function call,
// returning only the value of the object. To call GetDataValueBytes, you must first
// have called one of the Next/Previous functions.
func (j *Journal) GetDataValueBytes(field string) ([]byte, error) {
	val, err := j.GetDataBytes(field)
	if err != nil {
		return nil, err
	}

	return bytes.SplitN(val, []byte("="), 2)[1], nil
}

// GetEntry returns a full representation of the journal entry referenced by the
// last completed Next/Previous function call, with all key-value pairs of data
// as well as address fields (cursor, realtime timestamp and monotonic timestamp).
// To call GetEntry, you must first have called one of the Next/Previous functions.
func (j *Journal) GetEntry() (*JournalEntry, error) {
	sd_journal_get_realtime_usec, err := getFunction("sd_journal_get_realtime_usec")
	if err != nil {
		return nil, err
	}

	sd_journal_get_monotonic_usec, err := getFunction("sd_journal_get_monotonic_usec")
	if err != nil {
		return nil, err
	}

	sd_journal_get_cursor, err := getFunction("sd_journal_get_cursor")
	if err != nil {
		return nil, err
	}

	sd_journal_restart_data, err := getFunction("sd_journal_restart_data")
	if err != nil {
		return nil, err
	}

	sd_journal_enumerate_data, err := getFunction("sd_journal_enumerate_data")
	if err != nil {
		return nil, err
	}

	j.mu.Lock()
	defer j.mu.Unlock()

	var r  /*line :750:8*/_Ctype_int /*line :750:13*/
	entry := &JournalEntry{Fields: make(map[string]string)}

	var realtimeUsec  /*line :753:19*/_Ctype_uint64_t /*line :753:29*/
	r = func() _Ctype_int{ _cgo0 := /*line :754:40*/sd_journal_get_realtime_usec; _cgo1 := /*line :754:70*/j.cjournal; var _cgo2 *_Ctype_uint64_t = /*line :754:82*/&realtimeUsec; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :754:96*/_Cfunc_my_sd_journal_get_realtime_usec(_cgo0, _cgo1, _cgo2); }()
	if r < 0 {
		return nil, fmt.Errorf("failed to get realtime timestamp: %s", syscall.Errno(-r).Error())
	}

	entry.RealtimeTimestamp = uint64(realtimeUsec)

	var monotonicUsec  /*line :761:20*/_Ctype_uint64_t /*line :761:30*/
	var boot_id  /*line :762:14*/_Ctype_sd_id128_t /*line :762:26*/

	r = func() _Ctype_int{ _cgo0 := /*line :764:41*/sd_journal_get_monotonic_usec; _cgo1 := /*line :764:72*/j.cjournal; var _cgo2 *_Ctype_uint64_t = /*line :764:84*/&monotonicUsec; var _cgo3 *_Ctype_sd_id128_t = /*line :764:100*/&boot_id; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :764:109*/_Cfunc_my_sd_journal_get_monotonic_usec(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if r < 0 {
		return nil, fmt.Errorf("failed to get monotonic timestamp: %s", syscall.Errno(-r).Error())
	}

	entry.MonotonicTimestamp = uint64(monotonicUsec)

	var c * /*line :771:9*/_Ctype_char /*line :771:15*/
	// since the pointer is mutated by sd_journal_get_cursor, need to wait
	// until after the call to free the memory
	r = func() _Ctype_int{ _cgo0 := /*line :774:33*/sd_journal_get_cursor; _cgo1 := /*line :774:56*/j.cjournal; _cgoBase2 := /*line :774:68*/&c; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :774:71*/_Cfunc_my_sd_journal_get_cursor(_cgo0, _cgo1, _cgo2); }()
	defer func() func() { _cgo0 := /*line :775:15*/unsafe.Pointer(c); return func() { _cgoCheckPointer(_cgo0, nil); /*line :775:33*/_Cfunc_free(_cgo0); }}()()
	if r < 0 {
		return nil, fmt.Errorf("failed to get cursor: %s", syscall.Errno(-r).Error())
	}

	entry.Cursor = ( /*line :780:17*/_Cfunc_GoString /*line :780:26*/)(c)

	// Implements the JOURNAL_FOREACH_DATA_RETVAL macro from journal-internal.h
	var d unsafe.Pointer
	var l  /*line :784:8*/_Ctype_size_t /*line :784:16*/
	func() { _cgo0 := /*line :785:31*/sd_journal_restart_data; _cgo1 := /*line :785:56*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :785:67*/_Cfunc_my_sd_journal_restart_data(_cgo0, _cgo1); }()
	for {
		r = func() _Ctype_int{ _cgo0 := /*line :787:38*/sd_journal_enumerate_data; _cgo1 := /*line :787:65*/j.cjournal; _cgoBase2 := /*line :787:77*/&d; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_size_t = /*line :787:81*/&l; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :787:84*/_Cfunc_my_sd_journal_enumerate_data(_cgo0, _cgo1, _cgo2, _cgo3); }()
		if r == 0 {
			break
		}

		if r < 0 {
			return nil, fmt.Errorf("failed to read message field: %s", syscall.Errno(-r).Error())
		}

		msg := ( /*line :796:10*/_Cfunc_GoStringN /*line :796:20*/)((* /*line :796:24*/_Ctype_char /*line :796:30*/)(d),  /*line :796:36*/_Ctype_int /*line :796:41*/(l))
		kv := strings.SplitN(msg, "=", 2)
		if len(kv) < 2 {
			return nil, fmt.Errorf("failed to parse field")
		}

		entry.Fields[kv[0]] = kv[1]
	}

	return entry, nil
}

// SetDataThreshold sets the data field size threshold for data returned by
// GetData. To retrieve the complete data fields this threshold should be
// turned off by setting it to 0, so that the library always returns the
// complete data objects.
func (j *Journal) SetDataThreshold(threshold uint64) error {
	sd_journal_set_data_threshold, err := getFunction("sd_journal_set_data_threshold")
	if err != nil {
		return err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :819:42*/sd_journal_set_data_threshold; _cgo1 := /*line :819:73*/j.cjournal; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :819:93*/(threshold); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :819:105*/_Cfunc_my_sd_journal_set_data_threshold(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to set data threshold: %s", syscall.Errno(-r).Error())
	}

	return nil
}

// GetRealtimeUsec gets the realtime (wallclock) timestamp of the journal
// entry referenced by the last completed Next/Previous function call. To
// call GetRealtimeUsec, you must first have called one of the Next/Previous
// functions.
func (j *Journal) GetRealtimeUsec() (uint64, error) {
	var usec  /*line :834:11*/_Ctype_uint64_t /*line :834:21*/

	sd_journal_get_realtime_usec, err := getFunction("sd_journal_get_realtime_usec")
	if err != nil {
		return 0, err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :842:41*/sd_journal_get_realtime_usec; _cgo1 := /*line :842:71*/j.cjournal; var _cgo2 *_Ctype_uint64_t = /*line :842:83*/&usec; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :842:89*/_Cfunc_my_sd_journal_get_realtime_usec(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	if r < 0 {
		return 0, fmt.Errorf("failed to get realtime timestamp: %s", syscall.Errno(-r).Error())
	}

	return uint64(usec), nil
}

// GetMonotonicUsec gets the monotonic timestamp of the journal entry
// referenced by the last completed Next/Previous function call. To call
// GetMonotonicUsec, you must first have called one of the Next/Previous
// functions.
func (j *Journal) GetMonotonicUsec() (uint64, error) {
	var usec  /*line :857:11*/_Ctype_uint64_t /*line :857:21*/
	var boot_id  /*line :858:14*/_Ctype_sd_id128_t /*line :858:26*/

	sd_journal_get_monotonic_usec, err := getFunction("sd_journal_get_monotonic_usec")
	if err != nil {
		return 0, err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :866:42*/sd_journal_get_monotonic_usec; _cgo1 := /*line :866:73*/j.cjournal; var _cgo2 *_Ctype_uint64_t = /*line :866:85*/&usec; var _cgo3 *_Ctype_sd_id128_t = /*line :866:92*/&boot_id; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :866:101*/_Cfunc_my_sd_journal_get_monotonic_usec(_cgo0, _cgo1, _cgo2, _cgo3); }()
	j.mu.Unlock()

	if r < 0 {
		return 0, fmt.Errorf("failed to get monotonic timestamp: %s", syscall.Errno(-r).Error())
	}

	return uint64(usec), nil
}

// GetCursor gets the cursor of the last journal entry reeferenced by the
// last completed Next/Previous function call. To call GetCursor, you must
// first have called one of the Next/Previous functions.
func (j *Journal) GetCursor() (string, error) {
	sd_journal_get_cursor, err := getFunction("sd_journal_get_cursor")
	if err != nil {
		return "", err
	}

	var d * /*line :885:9*/_Ctype_char /*line :885:15*/
	// since the pointer is mutated by sd_journal_get_cursor, need to wait
	// until after the call to free the memory

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :890:34*/sd_journal_get_cursor; _cgo1 := /*line :890:57*/j.cjournal; _cgoBase2 := /*line :890:69*/&d; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :890:72*/_Cfunc_my_sd_journal_get_cursor(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()
	defer func() func() { _cgo0 := /*line :892:15*/unsafe.Pointer(d); return func() { _cgoCheckPointer(_cgo0, nil); /*line :892:33*/_Cfunc_free(_cgo0); }}()()

	if r < 0 {
		return "", fmt.Errorf("failed to get cursor: %s", syscall.Errno(-r).Error())
	}

	cursor := ( /*line :898:12*/_Cfunc_GoString /*line :898:21*/)(d)

	return cursor, nil
}

// TestCursor checks whether the current position in the journal matches the
// specified cursor
func (j *Journal) TestCursor(cursor string) error {
	sd_journal_test_cursor, err := getFunction("sd_journal_test_cursor")
	if err != nil {
		return err
	}

	c := ( /*line :911:7*/_Cfunc_CString /*line :911:15*/)(cursor)
	defer func() func() { _cgo0 := /*line :912:15*/unsafe.Pointer(c); return func() { _cgoCheckPointer(_cgo0, nil); /*line :912:33*/_Cfunc_free(_cgo0); }}()()

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :915:35*/sd_journal_test_cursor; _cgo1 := /*line :915:59*/j.cjournal; var _cgo2 *_Ctype_char = /*line :915:71*/c; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :915:73*/_Cfunc_my_sd_journal_test_cursor(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to test to cursor %q: %s", cursor, syscall.Errno(-r).Error())
	} else if r == 0 {
		return ErrNoTestCursor
	}

	return nil
}

// SeekHead seeks to the beginning of the journal, i.e. the oldest available
// entry. This call must be followed by a call to Next before any call to
// Get* will return data about the first element.
func (j *Journal) SeekHead() error {
	sd_journal_seek_head, err := getFunction("sd_journal_seek_head")
	if err != nil {
		return err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :937:33*/sd_journal_seek_head; _cgo1 := /*line :937:55*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :937:66*/_Cfunc_my_sd_journal_seek_head(_cgo0, _cgo1); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to seek to head of journal: %s", syscall.Errno(-r).Error())
	}

	return nil
}

// SeekTail may be used to seek to the end of the journal, i.e. the most recent
// available entry. This call must be followed by a call to Previous before any
// call to Get* will return data about the last element.
func (j *Journal) SeekTail() error {
	sd_journal_seek_tail, err := getFunction("sd_journal_seek_tail")
	if err != nil {
		return err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :957:33*/sd_journal_seek_tail; _cgo1 := /*line :957:55*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :957:66*/_Cfunc_my_sd_journal_seek_tail(_cgo0, _cgo1); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to seek to tail of journal: %s", syscall.Errno(-r).Error())
	}

	return nil
}

// SeekRealtimeUsec seeks to the entry with the specified realtime (wallclock)
// timestamp, i.e. CLOCK_REALTIME. This call must be followed by a call to
// Next/Previous before any call to Get* will return data about the sought entry.
func (j *Journal) SeekRealtimeUsec(usec uint64) error {
	sd_journal_seek_realtime_usec, err := getFunction("sd_journal_seek_realtime_usec")
	if err != nil {
		return err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :977:42*/sd_journal_seek_realtime_usec; _cgo1 := /*line :977:73*/j.cjournal; var _cgo2 _Ctype_uint64_t = _Ctype_uint64_t /*line :977:95*/(usec); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :977:102*/_Cfunc_my_sd_journal_seek_realtime_usec(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to seek to %d: %s", usec, syscall.Errno(-r).Error())
	}

	return nil
}

// SeekCursor seeks to a concrete journal cursor. This call must be
// followed by a call to Next/Previous before any call to Get* will return
// data about the sought entry.
func (j *Journal) SeekCursor(cursor string) error {
	sd_journal_seek_cursor, err := getFunction("sd_journal_seek_cursor")
	if err != nil {
		return err
	}

	c := ( /*line :996:7*/_Cfunc_CString /*line :996:15*/)(cursor)
	defer func() func() { _cgo0 := /*line :997:15*/unsafe.Pointer(c); return func() { _cgoCheckPointer(_cgo0, nil); /*line :997:33*/_Cfunc_free(_cgo0); }}()()

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :1000:35*/sd_journal_seek_cursor; _cgo1 := /*line :1000:59*/j.cjournal; var _cgo2 *_Ctype_char = /*line :1000:71*/c; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :1000:73*/_Cfunc_my_sd_journal_seek_cursor(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	if r < 0 {
		return fmt.Errorf("failed to seek to cursor %q: %s", cursor, syscall.Errno(-r).Error())
	}

	return nil
}

// Wait will synchronously wait until the journal gets changed. The maximum time
// this call sleeps may be controlled with the timeout parameter.  If
// sdjournal.IndefiniteWait is passed as the timeout parameter, Wait will
// wait indefinitely for a journal change.
func (j *Journal) Wait(timeout time.Duration) int {
	var to uint64

	sd_journal_wait, err := getFunction("sd_journal_wait")
	if err != nil {
		return -1
	}

	if timeout == IndefiniteWait {
		// sd_journal_wait(3) calls for a (uint64_t) -1 to be passed to signify
		// indefinite wait, but using a -1 overflows our C.uint64_t, so we use an
		// equivalent hex value.
		to = 0xffffffffffffffff
	} else {
		to = uint64(timeout / time.Microsecond)
	}
	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :1031:28*/sd_journal_wait; _cgo1 := /*line :1031:45*/j.cjournal; var _cgo2 _Ctype_uint64_t = _Ctype_uint64_t /*line :1031:67*/(to); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :1031:72*/_Cfunc_my_sd_journal_wait(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	return int(r)
}

// GetUsage returns the journal disk space usage, in bytes.
func (j *Journal) GetUsage() (uint64, error) {
	var out  /*line :1039:10*/_Ctype_uint64_t /*line :1039:20*/

	sd_journal_get_usage, err := getFunction("sd_journal_get_usage")
	if err != nil {
		return 0, err
	}

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :1047:33*/sd_journal_get_usage; _cgo1 := /*line :1047:55*/j.cjournal; var _cgo2 *_Ctype_uint64_t = /*line :1047:67*/&out; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :1047:72*/_Cfunc_my_sd_journal_get_usage(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()

	if r < 0 {
		return 0, fmt.Errorf("failed to get journal disk space usage: %s", syscall.Errno(-r).Error())
	}

	return uint64(out), nil
}

// GetUniqueValues returns all unique values for a given field.
func (j *Journal) GetUniqueValues(field string) ([]string, error) {
	var result []string

	sd_journal_query_unique, err := getFunction("sd_journal_query_unique")
	if err != nil {
		return nil, err
	}

	sd_journal_enumerate_unique, err := getFunction("sd_journal_enumerate_unique")
	if err != nil {
		return nil, err
	}

	sd_journal_restart_unique, err := getFunction("sd_journal_restart_unique")
	if err != nil {
		return nil, err
	}

	j.mu.Lock()
	defer j.mu.Unlock()

	f := ( /*line :1079:7*/_Cfunc_CString /*line :1079:15*/)(field)
	defer func() func() { _cgo0 := /*line :1080:15*/unsafe.Pointer(f); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1080:33*/_Cfunc_free(_cgo0); }}()()

	r := func() _Ctype_int{ _cgo0 := /*line :1082:36*/sd_journal_query_unique; _cgo1 := /*line :1082:61*/j.cjournal; var _cgo2 *_Ctype_char = /*line :1082:73*/f; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :1082:75*/_Cfunc_my_sd_journal_query_unique(_cgo0, _cgo1, _cgo2); }()

	if r < 0 {
		return nil, fmt.Errorf("failed to query journal: %s", syscall.Errno(-r).Error())
	}

	// Implements the SD_JOURNAL_FOREACH_UNIQUE macro from sd-journal.h
	var d unsafe.Pointer
	var l  /*line :1090:8*/_Ctype_size_t /*line :1090:16*/
	func() { _cgo0 := /*line :1091:33*/sd_journal_restart_unique; _cgo1 := /*line :1091:60*/j.cjournal; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :1091:71*/_Cfunc_my_sd_journal_restart_unique(_cgo0, _cgo1); }()
	for {
		r = func() _Ctype_int{ _cgo0 := /*line :1093:40*/sd_journal_enumerate_unique; _cgo1 := /*line :1093:69*/j.cjournal; _cgoBase2 := /*line :1093:81*/&d; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_size_t = /*line :1093:85*/&l; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1093:88*/_Cfunc_my_sd_journal_enumerate_unique(_cgo0, _cgo1, _cgo2, _cgo3); }()
		if r == 0 {
			break
		}

		if r < 0 {
			return nil, fmt.Errorf("failed to read message field: %s", syscall.Errno(-r).Error())
		}

		msg := ( /*line :1102:10*/_Cfunc_GoStringN /*line :1102:20*/)((* /*line :1102:24*/_Ctype_char /*line :1102:30*/)(d),  /*line :1102:36*/_Ctype_int /*line :1102:41*/(l))
		kv := strings.SplitN(msg, "=", 2)
		if len(kv) < 2 {
			return nil, fmt.Errorf("failed to parse field")
		}

		result = append(result, kv[1])
	}

	return result, nil
}

// GetCatalog retrieves a message catalog entry for the journal entry referenced
// by the last completed Next/Previous function call. To call GetCatalog, you
// must first have called one of these functions.
func (j *Journal) GetCatalog() (string, error) {
	sd_journal_get_catalog, err := getFunction("sd_journal_get_catalog")
	if err != nil {
		return "", err
	}

	var c * /*line :1123:9*/_Ctype_char /*line :1123:15*/

	j.mu.Lock()
	r := func() _Ctype_int{ _cgo0 := /*line :1126:35*/sd_journal_get_catalog; _cgo1 := /*line :1126:59*/j.cjournal; _cgoBase2 := /*line :1126:71*/&c; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1126:74*/_Cfunc_my_sd_journal_get_catalog(_cgo0, _cgo1, _cgo2); }()
	j.mu.Unlock()
	defer func() func() { _cgo0 := /*line :1128:15*/unsafe.Pointer(c); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1128:33*/_Cfunc_free(_cgo0); }}()()

	if r < 0 {
		return "", fmt.Errorf("failed to retrieve catalog entry for current journal entry: %s", syscall.Errno(-r).Error())
	}

	catalog := ( /*line :1134:13*/_Cfunc_GoString /*line :1134:22*/)(c)

	return catalog, nil
}

// GetBootID get systemd boot id
func (j *Journal) GetBootID() (string, error) {
	sd_id128_get_boot, err := getFunction("sd_id128_get_boot")
	if err != nil {
		return "", err
	}

	var boot_id  /*line :1146:14*/_Ctype_sd_id128_t /*line :1146:26*/
	r := func() _Ctype_int{ _cgo0 := /*line :1147:30*/sd_id128_get_boot; var _cgo1 *_Ctype_sd_id128_t = /*line :1147:49*/&boot_id; _cgoCheckPointer(_cgo0, nil); return /*line :1147:58*/_Cfunc_my_sd_id128_get_boot(_cgo0, _cgo1); }()
	if r < 0 {
		return "", fmt.Errorf("failed to get boot id: %s", syscall.Errno(-r).Error())
	}

	sd_id128_to_string, err := getFunction("sd_id128_to_string")
	if err != nil {
		return "", err
	}

	id128StringMax :=  /*line :1157:20*/_Ctype_size_t /*line :1157:28*/(( /*line :1157:29*/_Ciconst_SD_ID128_STRING_MAX /*line :1157:49*/))
	c := (* /*line :1158:9*/_Ctype_char /*line :1158:15*/)(( /*line :1158:17*/_Cfunc__CMalloc /*line :1158:24*/)(id128StringMax))
	defer func() func() { _cgo0 := /*line :1159:15*/unsafe.Pointer(c); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1159:33*/_Cfunc_free(_cgo0); }}()()
	func() *_Ctype_char{ _cgo0 := /*line :1160:26*/sd_id128_to_string; var _cgo1 _Ctype_sd_id128_t = /*line :1160:46*/boot_id; var _cgo2 *_Ctype_char = /*line :1160:55*/c; _cgoCheckPointer(_cgo0, nil); return /*line :1160:57*/_Cfunc_my_sd_id128_to_string(_cgo0, _cgo1, _cgo2); }()

	bootID := ( /*line :1162:12*/_Cfunc_GoString /*line :1162:21*/)(c)
	if len(bootID) <= 0 {
		return "", fmt.Errorf("get boot id %s is not valid", bootID)
	}

	return bootID, nil
}
