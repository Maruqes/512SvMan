// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/marques/.gvm/pkgsets/go1.25.0/global/pkg/mod/libvirt.org/go/libvirt@v1.11006.0/stream.go:1:1
/*
 * This file is part of the libvirt-go-module project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Copyright (c) 2013 Alex Zorin
 * Copyright (C) 2016 Red Hat, Inc.
 *
 */

package libvirt

/*
#cgo !libvirt_dlopen pkg-config: libvirt
#cgo libvirt_dlopen LDFLAGS: -ldl
#cgo libvirt_dlopen CFLAGS: -DLIBVIRT_DLOPEN
#include "stream_helper.h"
*/
import _ "unsafe"
import (
	"io"
	"unsafe"
)

type StreamFlags uint

const (
	STREAM_NONBLOCK = StreamFlags(( /*line :44:32*/_Ciconst_VIR_STREAM_NONBLOCK /*line :44:52*/))
)

type StreamEventType int

const (
	STREAM_EVENT_READABLE = StreamEventType(( /*line :50:42*/_Ciconst_VIR_STREAM_EVENT_READABLE /*line :50:68*/))
	STREAM_EVENT_WRITABLE = StreamEventType(( /*line :51:42*/_Ciconst_VIR_STREAM_EVENT_WRITABLE /*line :51:68*/))
	STREAM_EVENT_ERROR    = StreamEventType(( /*line :52:42*/_Ciconst_VIR_STREAM_EVENT_ERROR /*line :52:65*/))
	STREAM_EVENT_HANGUP   = StreamEventType(( /*line :53:42*/_Ciconst_VIR_STREAM_EVENT_HANGUP /*line :53:66*/))
)

type StreamRecvFlagsValues int

const (
	STREAM_RECV_STOP_AT_HOLE = StreamRecvFlagsValues(( /*line :59:51*/_Ciconst_VIR_STREAM_RECV_STOP_AT_HOLE /*line :59:80*/))
)

type Stream struct {
	ptr  /*line :63:6*/_Ctype_virStreamPtr /*line :63:20*/
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamAbort
func (v *Stream) Abort() error {
	var err  /*line :68:10*/_Ctype_virError /*line :68:20*/
	result := func() _Ctype_int{ _cgo0 := /*line :69:36*/v.ptr; _cgoBase1 := /*line :69:43*/&err; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :69:48*/_Cfunc_virStreamAbortWrapper(_cgo0, _cgo1); }()
	if result == -1 {
		return makeError(&err)
	}

	return nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamFinish
func (v *Stream) Finish() error {
	var err  /*line :79:10*/_Ctype_virError /*line :79:20*/
	result := func() _Ctype_int{ _cgo0 := /*line :80:37*/v.ptr; _cgoBase1 := /*line :80:44*/&err; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :80:49*/_Cfunc_virStreamFinishWrapper(_cgo0, _cgo1); }()
	if result == -1 {
		return makeError(&err)
	}

	return nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamFree
func (v *Stream) Free() error {
	var err  /*line :90:10*/_Ctype_virError /*line :90:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :91:32*/v.ptr; _cgoBase1 := /*line :91:39*/&err; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :91:44*/_Cfunc_virStreamFreeWrapper(_cgo0, _cgo1); }()
	if ret == -1 {
		return makeError(&err)
	}
	return nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamRef
func (c *Stream) Ref() error {
	var err  /*line :100:10*/_Ctype_virError /*line :100:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :101:31*/c.ptr; _cgoBase1 := /*line :101:38*/&err; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :101:43*/_Cfunc_virStreamRefWrapper(_cgo0, _cgo1); }()
	if ret == -1 {
		return makeError(&err)
	}
	return nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamRecv
func (v *Stream) Recv(p []byte) (int, error) {
	np := len(p)
	var err  /*line :111:10*/_Ctype_virError /*line :111:20*/
	var pPtr * /*line :112:12*/_Ctype_char /*line :112:18*/ = nil
	if np > 0 {
		pPtr = (* /*line :114:12*/_Ctype_char /*line :114:18*/)(unsafe.Pointer(&p[0]))
	}
	n := func() _Ctype_int{ _cgo0 := /*line :116:30*/v.ptr; var _cgo1 *_Ctype_char = /*line :116:37*/pPtr; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :116:51*/(np); _cgoBase3 := /*line :116:57*/&err; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :116:62*/_Cfunc_virStreamRecvWrapper(_cgo0, _cgo1, _cgo2, _cgo3); }()
	// -2 == blocking, -3 == in hole
	if n == -2 || n == -3 {
		return int(n), nil
	}
	if n < 0 {
		return 0, makeError(&err)
	}
	if n == 0 {
		return 0, io.EOF
	}

	return int(n), nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamRecvFlags
func (v *Stream) RecvFlags(p []byte, flags StreamRecvFlagsValues) (int, error) {
	np := len(p)
	var err  /*line :134:10*/_Ctype_virError /*line :134:20*/
	var pPtr * /*line :135:12*/_Ctype_char /*line :135:18*/ = nil
	if np > 0 {
		pPtr = (* /*line :137:12*/_Ctype_char /*line :137:18*/)(unsafe.Pointer(&p[0]))
	}
	n := func() _Ctype_int{ _cgo0 := /*line :139:35*/v.ptr; var _cgo1 *_Ctype_char = /*line :139:42*/pPtr; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :139:56*/(np); var _cgo3 _Ctype_uint = _Ctype_uint /*line :139:68*/(flags); _cgoBase4 := /*line :139:77*/&err; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :139:82*/_Cfunc_virStreamRecvFlagsWrapper(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	// -2 == blocking, -3 == in hole
	if n == -2 || n == -3 {
		return int(n), nil
	}
	if n < 0 {
		return 0, makeError(&err)
	}
	if n == 0 {
		return 0, io.EOF
	}

	return int(n), nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamRecvHole
func (v *Stream) RecvHole(flags uint32) (int64, error) {
	var len  /*line :156:10*/_Ctype_longlong /*line :156:20*/
	var err  /*line :157:10*/_Ctype_virError /*line :157:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :158:36*/v.ptr; var _cgo1 *_Ctype_longlong = /*line :158:43*/&len; var _cgo2 _Ctype_uint = _Ctype_uint /*line :158:55*/(flags); _cgoBase3 := /*line :158:64*/&err; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :158:69*/_Cfunc_virStreamRecvHoleWrapper(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret < 0 {
		return 0, makeError(&err)
	}

	return int64(len), nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamSend
func (v *Stream) Send(p []byte) (int, error) {
	np := len(p)
	var err  /*line :169:10*/_Ctype_virError /*line :169:20*/
	var pPtr * /*line :170:12*/_Ctype_char /*line :170:18*/ = nil
	if np > 0 {
		pPtr = (* /*line :172:12*/_Ctype_char /*line :172:18*/)(unsafe.Pointer(&p[0]))
	}
	n := func() _Ctype_int{ _cgo0 := /*line :174:30*/v.ptr; var _cgo1 *_Ctype_char = /*line :174:37*/pPtr; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :174:51*/(np); _cgoBase3 := /*line :174:57*/&err; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :174:62*/_Cfunc_virStreamSendWrapper(_cgo0, _cgo1, _cgo2, _cgo3); }()
	// -2 == blocking
	if n == -2 {
		return int(n), nil
	}
	if n < 0 {
		return 0, makeError(&err)
	}
	if n == 0 {
		return 0, io.EOF
	}

	return int(n), nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamSendHole
func (v *Stream) SendHole(len int64, flags uint32) error {
	var err  /*line :191:10*/_Ctype_virError /*line :191:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :192:36*/v.ptr; var _cgo1 _Ctype_longlong = _Ctype_longlong /*line :192:53*/(len); var _cgo2 _Ctype_uint = _Ctype_uint /*line :192:66*/(flags); _cgoBase3 := /*line :192:75*/&err; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :192:80*/_Cfunc_virStreamSendHoleWrapper(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret < 0 {
		return makeError(&err)
	}

	return nil
}

type StreamSinkFunc func(*Stream, []byte) (int, error)
type StreamSinkHoleFunc func(*Stream, int64) error

//export streamSinkCallback
func streamSinkCallback(stream  /*line :204:32*/_Ctype_virStreamPtr /*line :204:46*/, cdata * /*line :204:55*/_Ctype_char /*line :204:61*/, nbytes  /*line :204:70*/_Ctype_size_t /*line :204:78*/, callbackID int) int {
	callbackFunc := getCallbackId(callbackID)

	callback, ok := callbackFunc.(StreamSinkFunc)
	if !ok {
		panic("Incorrect stream sink func callback")
	}

	data := make([]byte, int(nbytes))
	for i := 0; i < int(nbytes); i++ {
		cdatabyte := (* /*line :214:18*/_Ctype_char /*line :214:24*/)(unsafe.Pointer(uintptr(unsafe.Pointer(cdata)) + (unsafe.Sizeof(*cdata) * uintptr(i))))
		data[i] = (byte)(*cdatabyte)
	}

	retnbytes, err := callback(&Stream{ptr: stream}, data)
	if err != nil {
		return -1
	}

	return retnbytes
}

//export streamSinkHoleCallback
func streamSinkHoleCallback(stream  /*line :227:36*/_Ctype_virStreamPtr /*line :227:50*/, length  /*line :227:59*/_Ctype_longlong /*line :227:69*/, callbackID int) int {
	callbackFunc := getCallbackId(callbackID)

	callback, ok := callbackFunc.(StreamSinkHoleFunc)
	if !ok {
		panic("Incorrect stream sink hole func callback")
	}

	err := callback(&Stream{ptr: stream}, int64(length))
	if err != nil {
		return -1
	}

	return 0
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamRecvAll
func (v *Stream) RecvAll(handler StreamSinkFunc) error {

	callbackID := registerCallbackId(handler)

	var err  /*line :248:10*/_Ctype_virError /*line :248:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :249:34*/v.ptr; var _cgo1 _Ctype_int = /*line :249:41*/(_Ctype_int /*line :249:47*/)(callbackID); _cgoBase2 := /*line :249:62*/&err; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :249:67*/_Cfunc_virStreamRecvAllHelper(_cgo0, _cgo1, _cgo2); }()
	freeCallbackId(callbackID)
	if ret == -1 {
		return makeError(&err)
	}

	return nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamSparseRecvAll
func (v *Stream) SparseRecvAll(handler StreamSinkFunc, holeHandler StreamSinkHoleFunc) error {
	callbackID := registerCallbackId(handler)
	holeCallbackID := registerCallbackId(holeHandler)

	var err  /*line :263:10*/_Ctype_virError /*line :263:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :264:40*/v.ptr; var _cgo1 _Ctype_int = /*line :264:47*/(_Ctype_int /*line :264:53*/)(callbackID); var _cgo2 _Ctype_int = /*line :264:68*/(_Ctype_int /*line :264:74*/)(holeCallbackID); _cgoBase3 := /*line :264:93*/&err; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :264:98*/_Cfunc_virStreamSparseRecvAllHelper(_cgo0, _cgo1, _cgo2, _cgo3); }()
	freeCallbackId(callbackID)
	freeCallbackId(holeCallbackID)
	if ret == -1 {
		return makeError(&err)
	}

	return nil
}

type StreamSourceFunc func(*Stream, int) ([]byte, error)
type StreamSourceHoleFunc func(*Stream) (bool, int64, error)
type StreamSourceSkipFunc func(*Stream, int64) error

//export streamSourceCallback
func streamSourceCallback(stream  /*line :279:34*/_Ctype_virStreamPtr /*line :279:48*/, cdata * /*line :279:57*/_Ctype_char /*line :279:63*/, nbytes  /*line :279:72*/_Ctype_size_t /*line :279:80*/, callbackID int) int {
	callbackFunc := getCallbackId(callbackID)

	callback, ok := callbackFunc.(StreamSourceFunc)
	if !ok {
		panic("Incorrect stream sink func callback")
	}

	data, err := callback(&Stream{ptr: stream}, (int)(nbytes))
	if err != nil {
		return -1
	}

	nretbytes := int(nbytes)
	if len(data) < nretbytes {
		nretbytes = len(data)
	}

	for i := 0; i < nretbytes; i++ {
		cdatabyte := (* /*line :298:18*/_Ctype_char /*line :298:24*/)(unsafe.Pointer(uintptr(unsafe.Pointer(cdata)) + (unsafe.Sizeof(*cdata) * uintptr(i))))
		*cdatabyte = ( /*line :299:17*/_Ctype_char /*line :299:23*/)(data[i])
	}

	return nretbytes
}

//export streamSourceHoleCallback
func streamSourceHoleCallback(stream  /*line :306:38*/_Ctype_virStreamPtr /*line :306:52*/, cinData * /*line :306:63*/_Ctype_int /*line :306:68*/, clength * /*line :306:79*/_Ctype_longlong /*line :306:89*/, callbackID int) int {
	callbackFunc := getCallbackId(callbackID)

	callback, ok := callbackFunc.(StreamSourceHoleFunc)
	if !ok {
		panic("Incorrect stream sink hole func callback")
	}

	inData, length, err := callback(&Stream{ptr: stream})
	if err != nil {
		return -1
	}

	if inData {
		*cinData = 1
	} else {
		*cinData = 0
	}
	*clength =  /*line :324:13*/_Ctype_longlong /*line :324:23*/(length)

	return 0
}

//export streamSourceSkipCallback
func streamSourceSkipCallback(stream  /*line :330:38*/_Ctype_virStreamPtr /*line :330:52*/, length  /*line :330:61*/_Ctype_longlong /*line :330:71*/, callbackID int) int {
	callbackFunc := getCallbackId(callbackID)

	callback, ok := callbackFunc.(StreamSourceSkipFunc)
	if !ok {
		panic("Incorrect stream sink skip func callback")
	}

	err := callback(&Stream{ptr: stream}, int64(length))
	if err != nil {
		return -1
	}

	return 0
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamSendAll
func (v *Stream) SendAll(handler StreamSourceFunc) error {

	callbackID := registerCallbackId(handler)

	var err  /*line :351:10*/_Ctype_virError /*line :351:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :352:34*/v.ptr; var _cgo1 _Ctype_int = /*line :352:41*/(_Ctype_int /*line :352:47*/)(callbackID); _cgoBase2 := /*line :352:62*/&err; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :352:67*/_Cfunc_virStreamSendAllHelper(_cgo0, _cgo1, _cgo2); }()
	freeCallbackId(callbackID)
	if ret == -1 {
		return makeError(&err)
	}

	return nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamSparseSendAll
func (v *Stream) SparseSendAll(handler StreamSourceFunc, holeHandler StreamSourceHoleFunc, skipHandler StreamSourceSkipFunc) error {
	callbackID := registerCallbackId(handler)
	holeCallbackID := registerCallbackId(holeHandler)
	skipCallbackID := registerCallbackId(skipHandler)

	var err  /*line :367:10*/_Ctype_virError /*line :367:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :368:40*/v.ptr; var _cgo1 _Ctype_int = /*line :368:47*/(_Ctype_int /*line :368:53*/)(callbackID); var _cgo2 _Ctype_int = /*line :368:68*/(_Ctype_int /*line :368:74*/)(holeCallbackID); var _cgo3 _Ctype_int = /*line :368:93*/(_Ctype_int /*line :368:99*/)(skipCallbackID); _cgoBase4 := /*line :368:118*/&err; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :368:123*/_Cfunc_virStreamSparseSendAllHelper(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	freeCallbackId(callbackID)
	freeCallbackId(holeCallbackID)
	freeCallbackId(skipCallbackID)
	if ret == -1 {
		return makeError(&err)
	}

	return nil
}

type StreamEventCallback func(*Stream, StreamEventType)

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamEventAddCallback
func (v *Stream) EventAddCallback(events StreamEventType, callback StreamEventCallback) error {
	callbackID := registerCallbackId(callback)

	var err  /*line :385:10*/_Ctype_virError /*line :385:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :386:43*/v.ptr; var _cgo1 _Ctype_int = /*line :386:50*/(_Ctype_int /*line :386:56*/)(events); var _cgo2 _Ctype_int = /*line :386:67*/(_Ctype_int /*line :386:73*/)(callbackID); _cgoBase3 := /*line :386:88*/&err; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :386:93*/_Cfunc_virStreamEventAddCallbackHelper(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret == -1 {
		return makeError(&err)
	}

	return nil
}

//export streamEventCallback
func streamEventCallback(st  /*line :395:29*/_Ctype_virStreamPtr /*line :395:43*/, events int, callbackID int) {
	callbackFunc := getCallbackId(callbackID)

	callback, ok := callbackFunc.(StreamEventCallback)
	if !ok {
		panic("Incorrect stream event func callback")
	}

	callback(&Stream{ptr: st}, StreamEventType(events))
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamEventUpdateCallback
func (v *Stream) EventUpdateCallback(events StreamEventType) error {
	var err  /*line :408:10*/_Ctype_virError /*line :408:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :409:47*/v.ptr; var _cgo1 _Ctype_int = /*line :409:54*/(_Ctype_int /*line :409:60*/)(events); _cgoBase2 := /*line :409:71*/&err; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :409:76*/_Cfunc_virStreamEventUpdateCallbackWrapper(_cgo0, _cgo1, _cgo2); }()
	if ret == -1 {
		return makeError(&err)
	}

	return nil
}

// See also https://libvirt.org/html/libvirt-libvirt-stream.html#virStreamEventRemoveCallback
func (v *Stream) EventRemoveCallback() error {
	var err  /*line :419:10*/_Ctype_virError /*line :419:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :420:47*/v.ptr; _cgoBase1 := /*line :420:54*/&err; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :420:59*/_Cfunc_virStreamEventRemoveCallbackWrapper(_cgo0, _cgo1); }()
	if ret == -1 {
		return makeError(&err)
	}

	return nil
}
